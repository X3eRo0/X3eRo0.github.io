<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta name="description" content='X3eRo0&#39;s Blog about Reverse Engineering'>
	<meta name="keywords" content='X3eRo0, Reverse, Reverse Engineering, Crackmes, blog'>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="generator" content="Hugo 0.63.2" />
	<link rel="stylesheet" type="text/css" href='https://x3ero0.tech/css/bootstrap.min.css'>
	<link rel="stylesheet" type="text/css" href='https://x3ero0.tech/css/custom.css'>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css" integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc=" crossorigin=anonymous>
	<link rel="stylesheet" type="text/css"  href="https://x3ero0.tech/css/ui.css">
	<title>Year3000</title>
	<nav class="navbar text-center sticky-top bg-white mt-2 mb-1">
		<a href='https://x3ero0.tech/'><span class="btn btn-sm btn-outline-primary">Home</span></a>
		<a href='https://x3ero0.tech/crackmes'><span class="btn btn-sm btn-outline-secondary">Crackmes</span></a>
		<a href='https://x3ero0.tech/posts'><span class="btn btn-sm btn-outline-success">Blog</span></a>
		<a href='https://x3ero0.tech/tags'><span class="btn btn-sm btn-outline-warning">Tags</span></a>
	</nav>
</head>
<body>
      <div id="content">


	<section class="container text-justified mt-3">
	  <h2 class="text-center mb-4">Year3000</h2>
	    <div class="text-monospace">
			

<link rel="stylesheet" href="https://x3ero0.tech/css/styles/monokai.css">
<script src="https://x3ero0.tech/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<h2 id="year3000-re---nullcon-hackim2020-ctf">Year3000 [RE - Nullcon Hackim2020 CTF]</h2>
<p><strong>Description</strong></p>
<hr>
<p><code>One day when I came home at lunchtime I heard a funny noise Went out to the back yard to find out If it was one of those rowdy boys Stood there was my neighbor called Peter And a flux capacitor I guess there must be quite some entropy in a flux capacitor... 
<br>
<br> Netcat Link : nc re.ctf.nullcon.net 1234</code></p>
<hr>
<p>we were given 3000 stripped ELF binaries some 64bit binaries and 32bit binaries. the description of the challenge did&rsquo;nt explained what exactly the task was, so i tried to connect to the given netcat link.


<pre><code class="plaintext">x3ero0 :: year3000 » nc re.ctf.nullcon.net 1234
1252.bin
></code></pre>
</p>
<p>

<br>



<br>

so it was clear that for each binary we need to send the correct password of the binary.
lets reverse engineer one of the binaries.


<br>



<br>
</p>
<pre><code>.text:00000510 ; ===========================================================================
.text:00000510
.text:00000510 ; Segment type: Pure code
.text:00000510 ; Segment permissions: Read/Execute
.text:00000510 _text           segment para public 'CODE' use32
.text:00000510                 assume cs:_text
.text:00000510                 ;org 510h
.text:00000510                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text:00000510
.text:00000510 ; =============== S U B R O U T I N E =======================================
.text:00000510
.text:00000510 ; Attributes: noreturn fuzzy-sp
.text:00000510
.text:00000510                 public start
.text:00000510 start           proc near               ; DATA XREF: LOAD:00000018↑o
.text:00000510                 xor     ebp, ebp
.text:00000512                 pop     esi
.text:00000513                 mov     ecx, esp
.text:00000515                 and     esp, 0FFFFFFF0h
.text:00000518                 push    eax
.text:00000519                 push    esp             ; stack_end
.text:0000051A                 push    edx             ; rtld_fini
.text:0000051B                 call    sub_542
.text:00000520                 add     ebx, 1AA0h
.text:00000526                 lea     eax, (nullsub_1 - 1FC0h)[ebx]
.text:0000052C                 push    eax             ; fini
.text:0000052D                 lea     eax, (sub_7B0 - 1FC0h)[ebx]
.text:00000533                 push    eax             ; init
.text:00000534                 push    ecx             ; ubp_av
.text:00000535                 push    esi             ; argc
.text:00000536                 push    ds:(off_1FF8 - 1FC0h)[ebx] ; main
.text:0000053C                 call    ___libc_start_main
.text:00000541                 hlt
.text:00000541 start           endp
</code></pre><p>

<br>



<br>
</p>
<p>i calculated the offset of main function through gdb and it was sub_6D0


<br>



<br>
</p>
<pre><code>.text:000006D0 ; __unwind {
.text:000006D0                 lea     ecx, [esp+4]
.text:000006D4                 and     esp, 0FFFFFFF0h
.text:000006D7                 push    dword ptr [ecx-4]
.text:000006DA                 push    ebp
.text:000006DB                 mov     ebp, esp
.text:000006DD                 push    ebx
.text:000006DE                 push    ecx
.text:000006DF                 sub     esp, 70h
.text:000006E2                 call    sub_550
.text:000006E7                 add     ebx, 18D9h
.text:000006ED                 mov     eax, large gs:14h
.text:000006F3                 mov     [ebp+var_C], eax
.text:000006F6                 xor     eax, eax
.text:000006F8                 mov     eax, ds:(stdin_ptr - 1FC0h)[ebx]
.text:000006FE                 mov     eax, [eax]
; ...
; ...
; ...
.text:00000723                 add     esp, 10h
.text:00000726                 mov     eax, ds:(stdin_ptr - 1FC0h)[ebx]
.text:0000072C                 mov     eax, [eax]
.text:0000072E                 sub     esp, 4
.text:00000731                 push    eax             ; stream
.text:00000732                 push    64h ; 'd'       ; n
.text:00000734                 lea     eax, [ebp+s]
.text:00000737                 push    eax             ; s
.text:00000738                 call    _fgets
.text:0000073D                 add     esp, 10h
.text:00000740                 sub     esp, 0Ch
.text:00000743                 lea     eax, [ebp+s]
.text:00000746                 push    eax
.text:00000747                 call    sub_64D ; Password Check Function
.text:0000074C                 add     esp, 10h
.text:0000074F                 mov     [ebp+var_74], eax
.text:00000752                 cmp     [ebp+var_74], 0
.text:00000756                 jz      short loc_76C
.text:00000758                 sub     esp, 0Ch
.text:0000075B                 lea     eax, (aWellDone - 1FC0h)[ebx] ; &quot;Well done&quot;
.text:00000761                 push    eax             ; s
.text:00000762                 call    _puts
.text:00000767                 add     esp, 10h
.text:0000076A                 jmp     short loc_77E
.text:0000076C ; ---------------------------------------------------------------------------
.text:0000076C
.text:0000076C loc_76C:                                ; CODE XREF: sub_6D0+86↑j
.text:0000076C                 sub     esp, 0Ch
.text:0000076F                 lea     eax, (aYouHaveFailed - 1FC0h)[ebx] ; &quot;You have failed&quot;
.text:00000775                 push    eax             ; s
.text:00000776                 call    _puts
.text:0000077B                 add     esp, 10h
.text:0000077E
.text:0000077E loc_77E:                                ; CODE XREF: sub_6D0+9A↑j
.text:0000077E                 cmp     [ebp+var_74], 1
.text:00000782                 setnz   al
.text:00000785                 movzx   eax, al
.text:00000788                 mov     edx, [ebp+var_C]
.text:0000078B                 xor     edx, large gs:14h
.text:00000792                 jz      short loc_799
.text:00000794                 call    sub_820
.text:00000799 ; ---------------------------------------------------------------------------
.text:00000799
.text:00000799 loc_799:                                ; CODE XREF: sub_6D0+C2↑j
.text:00000799                 lea     esp, [ebp-8]
.text:0000079C                 pop     ecx
.text:0000079D                 pop     ebx
.text:0000079E                 pop     ebp
.text:0000079F                 lea     esp, [ecx-4]
.text:000007A2                 retn
.text:000007A2 ; } // starts at 6D0
.text:000007A2 sub_6D0         endp
.text:000007A2
</code></pre><p>

<br>



<br>
</p>
<p>lets look at sub_64D


<br>



<br>
</p>
<pre><code>.text:0000064D ; =============== S U B R O U T I N E =======================================
.text:0000064D
.text:0000064D ; Attributes: bp-based frame
.text:0000064D
.text:0000064D sub_64D         proc near               ; CODE XREF: sub_6D0+77↓p
.text:0000064D
.text:0000064D var_15          = byte ptr -15h
.text:0000064D var_14          = dword ptr -14h
.text:0000064D var_10          = dword ptr -10h
.text:0000064D var_C           = dword ptr -0Ch
.text:0000064D var_4           = dword ptr -4
.text:0000064D arg_0           = dword ptr  8
.text:0000064D
.text:0000064D ; __unwind {
.text:0000064D                 push    ebp
.text:0000064E                 mov     ebp, esp
.text:00000650                 push    ebx
.text:00000651                 sub     esp, 00000014h
.text:00000654                 call    sub_7A3
.text:00000659                 add     eax, 1967h
.text:0000065E                 mov     [ebp+var_C], 54h ; 'T'
.text:00000665                 mov     [ebp+var_15], 63h ; 'c'
.text:00000669                 mov     [ebp+var_14], 1
.text:00000670                 mov     [ebp+var_10], 0
.text:00000677                 jmp     short loc_696
.text:00000679 ; ---------------------------------------------------------------------------
.text:00000679
.text:00000679 loc_679:                                ; CODE XREF: sub_64D+4F↓j
.text:00000679                 mov     ecx, [ebp+var_10]
.text:0000067C                 mov     edx, [ebp+arg_0]
.text:0000067F                 add     edx, ecx
.text:00000681                 movzx   edx, byte ptr [edx]
.text:00000684                 cmp     [ebp+var_15], dl
.text:00000687                 jz      short loc_692
.text:00000689                 mov     [ebp+var_14], 0
.text:00000690                 jmp     short loc_69E
.text:00000692 ; ---------------------------------------------------------------------------
.text:00000692
.text:00000692 loc_692:                                ; CODE XREF: sub_64D+3A↑j
.text:00000692                 add     [ebp+var_10], 1
.text:00000696
.text:00000696 loc_696:                                ; CODE XREF: sub_64D+2A↑j
.text:00000696                 mov     edx, [ebp+var_10]
.text:00000699                 cmp     edx, [ebp+var_C]
.text:0000069C                 jl      short loc_679
.text:0000069E
.text:0000069E loc_69E:                                ; CODE XREF: sub_64D+43↑j
.text:0000069E                 mov     ecx, [ebp+var_C]
.text:000006A1                 mov     edx, [ebp+arg_0]
.text:000006A4                 add     ecx, edx
.text:000006A6                 sub     esp, 4
.text:000006A9                 push    4               ; n
.text:000006AB                 lea     edx, (dword_2008 - 1FC0h)[eax]
.text:000006B1                 push    edx             ; s2
.text:000006B2                 push    ecx             ; s1
.text:000006B3                 mov     ebx, eax
.text:000006B5                 call    _memcmp
.text:000006BA                 add     esp, 10h
.text:000006BD                 test    eax, eax
.text:000006BF                 jz      short loc_6C8
.text:000006C1                 mov     [ebp+var_14], 0
.text:000006C8
.text:000006C8 loc_6C8:                                ; CODE XREF: sub_64D+72↑j
.text:000006C8                 mov     eax, [ebp+var_14]
.text:000006CB                 mov     ebx, [ebp+var_4]
.text:000006CE                 leave
.text:000006CF                 retn
.text:000006CF ; } // starts at 64D
.text:000006CF sub_64D         endp
.text:000006CF
</code></pre><p>

<br>



<br>
</p>
<p>if you see this function and notice that at 0x0000065e a number is loaded into dword [local_ch] and at 0x00000665 a character is loaded into byte [local_15h].


<br>



<br>
</p>
<pre><code>.text:0000065E                 mov     [ebp+var_C], 54h ; 'T'
.text:00000665                 mov     [ebp+var_15], 63h ; 'c'
</code></pre><p>

<br>



<br>
</p>
<p>the following loop after this simply checks if the user input is &lsquo;c&rsquo; *0x54
then comes a memcmp at 0x6b5. now to statically analyse the arguments passed to memcmp we need to figure out whats going at 0x6ab


<br>



<br>
</p>
<pre><code>.text:000006AB                 lea     edx, (unk_2008 - 1FC0h)[eax]
</code></pre><p>

<br>



<br>
</p>
<p>now lets see what exactly is the value of eax at this instruction. we scroll a little bit up</p>
<pre><code>.text:00000654                 call    sub_7A3
.text:00000659                 add     eax, 1967h
</code></pre><p>

<br>



<br>
</p>
<p>lets see what this function is at 0x7a3


<br>



<br>
</p>
<pre><code>.text:000007A3 sub_7A3         proc near               ; CODE XREF: sub_64D+7↑p
.text:000007A3 ; __unwind {
.text:000007A3                 mov     eax, [esp+0]
.text:000007A6                 retn
.text:000007A6 ; } // starts at 7A3
.text:000007A6 sub_7A3         endp
.text:000007A6
</code></pre><p>

<br>



<br>
</p>
<p>it returns the address which was pushed on the stack when this function was called.
basically eax = address_of_next_instruction_after_call_0x7a3, so eax = 0x00000659
and then eax += 0x1967, so eax = 0x1fc0.
okay now lets look at the instruction at 0x000006ab again


<br>



<br>
</p>
<pre><code>0x000006ab      8d9048000000   lea 	   edx, dword [eax + 0x48] 
</code></pre><p>

<br>



<br>
</p>
<p>so it becomes <code>lea edx, dword [0x1fc0 + 0x48] ; 0x2008</code>
and you can actually see that ida already calculated the offset for us.
so memcmp checks that the bytes after &lsquo;c&rsquo; * 0x54 with the dword value at 0x2008
which is <code>.data:00002008 dword_2008      dd 0A7C6D169h</code>


<br>



<br>
</p>



<div class="center">
  <img
    src="https://x3ero0.tech/img/year3000/main.png"
    alt="Dump Of 3.bin"
    decoding="async"
  />
</div>
<p>

<br>



<br>
</p>
<p>also one more thing to point out is that this value is always stored at the end of .data section. so the correct password for 3.bin is


<br>



<br>
</p>
<pre><code>import struct
print 'c' * 0x54 + struct.pack('&lt;I', 0xA7C6D169)
</code></pre><p>

<br>



<br>
</p>
<p>output -&gt;</p>
<pre><code>x3ero0 :: year3000 » python solve_3.py | ./3.bin
Well done
</code></pre><p>

<br>



<br>
</p>
<p>so i quickly wrote a script to fetch these values and generate a correct password for all the binaries both 64 bit binaries or 32 bit binaries.</p>
<p>exploit script &ndash;&gt;


<br>



<br>
</p>
<pre><code>from pwn import *
import base64


context.log_level = &quot;critical&quot;

def solve(filename):

	file = open(filename, &quot;rb&quot;).read()
	
	ELF64_Coun = 0x816
	ELF64_Valu = 0x81d

	ELF32_Coun = 0x65e
	ELF32_Valu = 0x665


	ELF64_Addr = 0x1010
	ELF32_Addr = 0x1008

	
	Format = ord(file[0x04])
	if (Format == 2):

		context.update(arch='amd64', os='linux')

		code_count = file[ELF64_Coun : ELF64_Coun+7]
		code_value = file[ELF64_Valu : ELF64_Valu+4]

		disa_count = disasm(code_count)
		disa_value = disasm(code_value)

		code_count = int(disa_count.split('0x')[-1], 16)
		code_value = chr(int(disa_value.split('0x')[-1], 16))

		#value = u64(file[ELF64_Addr : ELF64_Addr+8])
		value = file[ELF64_Addr : ELF64_Addr+8]
		value_n = u64(value)

		flag = code_value * code_count + value

	elif(Format == 1):

		context.update(arch='i386', os='linux')

		code_count = file[ELF32_Coun : ELF32_Coun+7]
		code_value = file[ELF32_Valu : ELF32_Valu+4]

		disa_count = disasm(code_count)
		disa_value = disasm(code_value)

		code_count = int(disa_count.split('0x')[-1], 16)
		code_value = chr(int(disa_value.split('0x')[-1], 16))

		#value = u32(file[ELF32_Addr:ELF32_Addr+4])
		value = file[ELF32_Addr:ELF32_Addr+4]
		value_n = u32(value)
		flag = code_value * code_count + value
	
	#print &quot;[!] file : &quot; + filename
	#print &quot;[!] count: &quot; + hex(code_count)
	#print &quot;[!] value: &quot; + code_value
	#print &quot;[!] numbe: &quot; + hex(value_n)

	return flag


def main():


	i = 0
	p = remote(&quot;re.ctf.nullcon.net&quot;, 1234)
	temp = &quot;&quot;
	while(i != 10):

		file = p.recvline().strip()

		a = p.recvuntil(&quot;&gt; &quot;)
		solver = solve(file)
		# .encode('base64') doesnt work with bytes 
		p.sendline(base64.b64encode(solver))
		#print str(solver).encode('base64')
		temp = p.recvline()
		if(&quot;Well done&quot; in temp):
			print &quot;[0x%.4x]\t&quot; % i+ file + '\t: Well Done'
		else:
			print &quot;[+] Failed:\t&quot; + file + &quot;\tdumping recieved data&quot;
			exit()
		i += 1

	print &quot;Flag: &quot; + p.recvline()
	p.close()
	exit()

if __name__ == &quot;__main__&quot;:
	main()
</code></pre><p>

<br>



<br>
</p>
<p>and running this script gives us the flag


<br>



<br>



<script id="asciicast-Dr0XnWhv3pzEa6biFKK7evLYC" src="https://asciinema.org/a/Dr0XnWhv3pzEa6biFKK7evLYC.js" async></script>
</p>

		</div>
	</section>


      </div>
  </body><footer>
  <div class="container-fluid bg-dark text-white text-monospace text-center mt-4">
    <small style="color:#ffffff">
    	<b>-=[ </b>
    	<a href="https://youtube.com/pulkitsinghaniapulkittech" style="color:#e6ffff">YouTube</a>
    	<a href="https://www.linkedin.com/in/pulkit-singh-singaria-500a53166/" style="color:#e6ffff">LinkedIn</a>
    	<a href="https://twitter.com/X3eRo0" style="color:#e6ffff">Twitter</a>
    	<a href="https://ctftime.org/user/43759" style="color:#e6ffff">CTFTime</a>
    	<b> ]=-</b>
    </small>
  </div>
</footer></html>
